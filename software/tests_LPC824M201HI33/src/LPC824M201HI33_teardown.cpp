/*
 * SPDX-License-Identifier: MIT
 *
 * Copyright (c) 2021 Bart Bilos
 * For conditions of distribution and use, see LICENSE file
 */
/**
 * @brief Teardown function that resets the LPC845 to a state
 * that more or less matches reset state
 */
#include <board.hpp>
#include <LPC824M201HI33_teardown.hpp>
#include <test_conditions.hpp>
#include <MinUnit.h>
#include <LPC82X_interrupts.hpp>

#define IOCON_NORMAL_DEFAULT 0x00000090 /**< Default value for most pins */
#define IOCON_I2CPIN_MASK (~0x00000400) /**< some I2C pins have no default value, so mask them */
#define IOCON_I2CPIN_DEFAULT 0x00000080 /**< I2C pins have some bits extra and lose some bits */
#define IOCON_XTAL_DEFAULT 0x00000080   /**< Crystal oscillator deviate from reset values */

/** @brief resets all the registers to their default states
 */
MINUNIT_TEARDOWN(LPC824M201HI33Teardown) {
  interrupt_SPI0 = NULL;
  interrupt_SPI1 = NULL;
  interrupt_UART0 = NULL;
  interrupt_UART1 = NULL;
  interrupt_UART2 = NULL;
  interrupt_I2C1 = NULL;
  interrupt_I2C0 = NULL;
  interrupt_SCT = NULL;
  interrupt_MRT = NULL;
  interrupt_CMP = NULL;
  interrupt_WDT = NULL;
  interrupt_BOD = NULL;
  interrupt_FLASH = NULL;
  interrupt_WKT = NULL;
  interrupt_ADC_SEQA = NULL;
  interrupt_ADC_SEQB = NULL;
  interrupt_ADC_THCMP = NULL;
  interrupt_ADC_OVR = NULL;
  interrupt_DMA = NULL;
  interrupt_I2C2 = NULL;
  interrupt_I2C3 = NULL;
  interrupt_PIN_INT0 = NULL;
  interrupt_PIN_INT1 = NULL;
  interrupt_PIN_INT2 = NULL;
  interrupt_PIN_INT3 = NULL;
  interrupt_PIN_INT4 = NULL;
  interrupt_PIN_INT5 = NULL;
  interrupt_PIN_INT6 = NULL;
  interrupt_PIN_INT7 = NULL;

  NVIC->ISER[0] = 0x00000000;
  NVIC->ICER[0] = 0xFF7FFFBB;
  NVIC->ISPR[0] = 0x00000000;
  NVIC->ICPR[0] = 0xFF7FFFBB;
  NVIC->IP[0] = 0x00000000;
  NVIC->IP[1] = 0x00000000;
  NVIC->IP[2] = 0x00000000;
  NVIC->IP[3] = 0x00000000;
  NVIC->IP[4] = 0x00000000;
  NVIC->IP[5] = 0x00000000;
  NVIC->IP[6] = 0x00000000;
  NVIC->IP[7] = 0x00000000;

  sysconEnableClocks(SYSCON, CLKCTRL_UART0 | CLKCTRL_I2C0 | CLKCTRL_I2C1);
  sysconDisableResets(SYSCON, RESETCTRL_UART0 | RESETCTRL_I2C0 | RESETCTRL_I2C1);
  sysconEnableResets(SYSCON, RESETCTRL_UART0 | RESETCTRL_I2C0 | RESETCTRL_I2C1);
  sysconDisableClocks(SYSCON, CLKCTRL_UART0 | CLKCTRL_I2C0 | CLKCTRL_I2C1);

  sysconEnableClocks(SYSCON, CLKCTRL_IOCON);
  IOCON->PIO[IOCON_PIO0_17] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_13] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_12] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_5] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_4] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_3] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_2] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_11] = IOCON_I2CPIN_DEFAULT;
  IOCON->PIO[IOCON_PIO0_10] = IOCON_I2CPIN_DEFAULT;
  IOCON->PIO[IOCON_PIO0_16] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_15] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_1] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_9] = IOCON_XTAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_8] = IOCON_XTAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_7] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_6] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_0] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_14] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_28] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_27] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_26] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_25] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_24] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_23] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_22] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_21] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_20] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_19] = IOCON_NORMAL_DEFAULT;
  IOCON->PIO[IOCON_PIO0_18] = IOCON_NORMAL_DEFAULT;
  sysconDisableClocks(SYSCON, CLKCTRL_IOCON);

  sysconEnableClocks(SYSCON, CLKCTRL_GPIO);
  GPIO->DIR[0] = 0x00000000;
  GPIO->MASK[0] = 0x00000000;
  GPIO->PIN[0] = 0x00000000;
  GPIO->SET[0] = 0x00000000;
  GPIO->DIRSET[0] = 0x00000000;
  // as the pinint clock is shared with gpio, set it up here

  sysconDisableClocks(SYSCON, CLKCTRL_GPIO);

  sysconEnableClocks(SYSCON, CLKCTRL_SWM);
  SWM->PINASSIGN[0] = 0xFFFFFFFF;
  SWM->PINASSIGN[1] = 0xFFFFFFFF;
  SWM->PINASSIGN[2] = 0xFFFFFFFF;
  SWM->PINASSIGN[3] = 0xFFFFFFFF;
  SWM->PINASSIGN[4] = 0xFFFFFFFF;
  SWM->PINASSIGN[5] = 0xFFFFFFFF;
  SWM->PINASSIGN[6] = 0xFFFFFFFF;
  SWM->PINASSIGN[7] = 0xFFFFFFFF;
  SWM->PINASSIGN[8] = 0xFFFFFFFF;
  SWM->PINASSIGN[9] = 0xFFFFFFFF;
  SWM->PINASSIGN[10] = 0xFFFFFFFF;
  SWM->PINASSIGN[11] = 0xFFFFFFFF;
  SWM->PINENABLE0 = 0xFFFFFE0F;
  sysconDisableClocks(SYSCON, CLKCTRL_SWM);

  // keep syscon as last
  SYSCON->PINTSEL[0] = 0;
  SYSCON->PINTSEL[1] = 0;
  SYSCON->PINTSEL[2] = 0;
  SYSCON->PINTSEL[3] = 0;
  SYSCON->PINTSEL[4] = 0;
  SYSCON->PINTSEL[5] = 0;
  SYSCON->PINTSEL[6] = 0;
  SYSCON->PINTSEL[7] = 0;
  minUnitCheck(LPC824M201HI33TeardownCorrect() == true);
}

/** @brief checks if all the registers to their default states
 *  @return if all registers are correctly torndown
 */
bool LPC824M201HI33TeardownCorrect(void) {
  TESTANDRETURN(interrupt_SPI0 == NULL);
  TESTANDRETURN(interrupt_SPI1 == NULL);
  TESTANDRETURN(interrupt_UART0 == NULL);
  TESTANDRETURN(interrupt_UART1 == NULL);
  TESTANDRETURN(interrupt_UART2 == NULL);
  TESTANDRETURN(interrupt_I2C1 == NULL);
  TESTANDRETURN(interrupt_I2C0 == NULL);
  TESTANDRETURN(interrupt_SCT == NULL);
  TESTANDRETURN(interrupt_MRT == NULL);
  TESTANDRETURN(interrupt_CMP == NULL);
  TESTANDRETURN(interrupt_WDT == NULL);
  TESTANDRETURN(interrupt_BOD == NULL);
  TESTANDRETURN(interrupt_FLASH == NULL);
  TESTANDRETURN(interrupt_WKT == NULL);
  TESTANDRETURN(interrupt_ADC_SEQA == NULL);
  TESTANDRETURN(interrupt_ADC_SEQB == NULL);
  TESTANDRETURN(interrupt_ADC_THCMP == NULL);
  TESTANDRETURN(interrupt_ADC_OVR == NULL);
  TESTANDRETURN(interrupt_DMA == NULL);
  TESTANDRETURN(interrupt_I2C2 == NULL);
  TESTANDRETURN(interrupt_I2C3 == NULL);
  TESTANDRETURN(interrupt_PIN_INT0 == NULL);
  TESTANDRETURN(interrupt_PIN_INT1 == NULL);
  TESTANDRETURN(interrupt_PIN_INT2 == NULL);
  TESTANDRETURN(interrupt_PIN_INT3 == NULL);
  TESTANDRETURN(interrupt_PIN_INT4 == NULL);
  TESTANDRETURN(interrupt_PIN_INT5 == NULL);
  TESTANDRETURN(interrupt_PIN_INT6 == NULL);
  TESTANDRETURN(interrupt_PIN_INT7 == NULL);

  TESTANDRETURN(NVIC->ISER[0] == 0x00000000);
  TESTANDRETURN(NVIC->ICER[0] == 0x00000000);
  TESTANDRETURN(NVIC->ISPR[0] == 0x00000000);
  TESTANDRETURN(NVIC->ICPR[0] == 0x00000000);
  TESTANDRETURN(NVIC->IP[0] == 0x00000000);
  TESTANDRETURN(NVIC->IP[1] == 0x00000000);
  TESTANDRETURN(NVIC->IP[2] == 0x00000000);
  TESTANDRETURN(NVIC->IP[3] == 0x00000000);
  TESTANDRETURN(NVIC->IP[4] == 0x00000000);
  TESTANDRETURN(NVIC->IP[5] == 0x00000000);
  TESTANDRETURN(NVIC->IP[6] == 0x00000000);
  TESTANDRETURN(NVIC->IP[7] == 0x00000000);

  // check i2c reset states
  sysconEnableClocks(SYSCON, CLKCTRL_I2C0 | CLKCTRL_I2C1);
  TESTANDRETURN(I2C0->CFG == 0x0);
  TESTANDRETURN(I2C0->STAT == 0x801);
  TESTANDRETURN(I2C0->MSTTIME == 0x77);
  TESTANDRETURN(I2C1->CFG == 0x0);
  TESTANDRETURN(I2C1->STAT == 0x801);
  TESTANDRETURN(I2C1->MSTTIME == 0x77);
  sysconDisableClocks(SYSCON, CLKCTRL_I2C0 | CLKCTRL_I2C1);
  // check IOCON reset state
  sysconEnableClocks(SYSCON, CLKCTRL_IOCON);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_17] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_13] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_12] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_5] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_4] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_3] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_2] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN((IOCON->PIO[IOCON_PIO0_11] & IOCON_I2CPIN_MASK) == IOCON_I2CPIN_DEFAULT);
  TESTANDRETURN((IOCON->PIO[IOCON_PIO0_10] & IOCON_I2CPIN_MASK) == IOCON_I2CPIN_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_16] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_15] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_1] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_9] == IOCON_XTAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_8] == IOCON_XTAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_7] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_6] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_0] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_14] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_28] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_27] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_26] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_25] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_24] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_23] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_22] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_21] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_20] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_19] == IOCON_NORMAL_DEFAULT);
  TESTANDRETURN(IOCON->PIO[IOCON_PIO0_18] == IOCON_NORMAL_DEFAULT);
  sysconDisableClocks(SYSCON, CLKCTRL_IOCON);
  // check SWM reset state
  sysconEnableClocks(SYSCON, CLKCTRL_SWM);
  TESTANDRETURN(SWM->PINASSIGN[0] == 0xFFFFFFFF);
  TESTANDRETURN(SWM->PINASSIGN[1] == 0xFFFFFFFF);
  TESTANDRETURN(SWM->PINASSIGN[2] == 0xFFFFFFFF);
  TESTANDRETURN(SWM->PINASSIGN[3] == 0xFFFFFFFF);
  TESTANDRETURN(SWM->PINASSIGN[4] == 0xFFFFFFFF);
  TESTANDRETURN(SWM->PINASSIGN[5] == 0xFFFFFFFF);
  TESTANDRETURN(SWM->PINASSIGN[6] == 0xFFFFFFFF);
  TESTANDRETURN(SWM->PINASSIGN[7] == 0xFFFFFFFF);
  TESTANDRETURN(SWM->PINASSIGN[8] == 0xFFFFFFFF);
  TESTANDRETURN(SWM->PINASSIGN[9] == 0xFFFFFFFF);
  TESTANDRETURN(SWM->PINASSIGN[10] == 0xFFFFFFFF);
  TESTANDRETURN(SWM->PINASSIGN[11] == 0xFFFFFFFF);
  TESTANDRETURN(SWM->PINENABLE0 == 0x01FFFE0F);  // does not match datasheet!
  sysconDisableClocks(SYSCON, CLKCTRL_SWM);
  // verify GPIO reset state
  sysconEnableClocks(SYSCON, CLKCTRL_GPIO);
  TESTANDRETURN(GPIO->DIR[0] == 0x00000000);
  TESTANDRETURN(GPIO->MASK[0] == 0x00000000);
  TESTANDRETURN(GPIO->SET[0] == 0x00000000);
  TESTANDRETURN(GPIO->DIRSET[0] == 0x00000000);
  sysconDisableClocks(SYSCON, CLKCTRL_GPIO);
  // verify UART0 reset state
  sysconEnableClocks(SYSCON, CLKCTRL_UART0);
  TESTANDRETURN(USART0->CFG == 0x00000000);
  TESTANDRETURN(USART0->CTL == 0x00000000);
  TESTANDRETURN((USART0->STAT & 0x0001FD6F) == 0x0000000E);
  TESTANDRETURN(USART0->INTENSET == 0x00000000);
  // this differs from the datasheet
  TESTANDRETURN((USART0->INTSTAT & 0x0001F96D) == 0x00000000);
  TESTANDRETURN(USART0->OSR == 0x0000000F);
  TESTANDRETURN(USART0->ADDR == 0x00000000);
  sysconDisableClocks(SYSCON, CLKCTRL_UART0);

  TESTANDRETURN(SYSCON->PINTSEL[0] == 0x00000000);
  TESTANDRETURN(SYSCON->PINTSEL[1] == 0x00000000);
  TESTANDRETURN(SYSCON->PINTSEL[2] == 0x00000000);
  TESTANDRETURN(SYSCON->PINTSEL[3] == 0x00000000);
  TESTANDRETURN(SYSCON->PINTSEL[4] == 0x00000000);
  TESTANDRETURN(SYSCON->PINTSEL[5] == 0x00000000);
  TESTANDRETURN(SYSCON->PINTSEL[6] == 0x00000000);
  TESTANDRETURN(SYSCON->PINTSEL[7] == 0x00000000);
  return true;
}